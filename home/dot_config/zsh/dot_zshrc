# Misc
bindkey -e
setopt no_beep

# Export
export LANG=ja_JP.utf8
export CLICOLOR=1
export EDITOR=nvim

# Alias
if [ -x /usr/bin/dircolors ]; then
  test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='ls --color=auto'
  alias dir='dir --color=auto'
  alias vdir='vdir --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
fi
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
# compatible with windows
alias sz='source ${ZDOTDIR}/.zshrc'
alias fd='fzf-cd'
alias n='npm'
alias p='pnpm'
alias nr='npm run'
alias ch='chezmoi'
alias amp='amplify'
alias tf='terraform'
alias dk='docker'
alias dkc='docker compose'
alias hex2dec="printf '%d\n'"
alias dec2hex="printf '%x\n'"
# linux only
alias clip='/mnt/c/Windows/system32/clip.exe'
alias explorer='/mnt/c/Windows/explorer.exe'

# Completion
fpath=(
  ${ZDOTDIR}/completions
  $(brew --prefix)/share/zsh/site-functions
  $(brew --prefix asdf)/etc/bash_completion.d
  ${fpath}
)
autoload -Uz compinit && compinit
# ignore case
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# Application specific settings
# asdf
source $(brew --prefix)/opt/asdf/libexec/asdf.sh
# direnv
eval "$(direnv hook zsh)"

# ========================== zsh-hooks ==========================
precmd() {
  # 前回のコマンドの終了コードを記録
  export PREVIOUS_EXIT_CODE=$?

  # git の状態を環境変数に記録
  save_git_status_to_env

  # Promptの更新
  PROMPT=`prompt_format`

  # 初回起動時以外､改行する
  if [ -z "$NEW_LINE_BEFORE_PROMPT" ]; then
      NEW_LINE_BEFORE_PROMPT=1
  elif [ "$NEW_LINE_BEFORE_PROMPT" -eq 1 ]; then
      echo ""
  fi
}

# ========================== functions ==========================
# Prompt
prompt_format() {
  local text='%{\e[38;5;' # set text color
  local bg='%{\e[48;5;'   # set background color
  local reset='%{\e[0m%}' # reset
  local sharp='\uE0B0'    # triangle

  local green='002m%}'
  local white='007m%}'
  local grey='008m%}'
  local red='009m%}'
  local blue='024m%}'
  local cian='036m%}'
  local sky='110m%}'
  local black='232m%}'
  local white_b='254m%}'

  # 前回の終了ステータス(正常)
  previous_status_o() {
    echo "${bg}${white_b}${text}${cian} ✔  ${bg}${grey}${text}${white_b}${sharp}"
  }
  # 前回の終了ステータス(異常)
  previous_status_x() {
    echo "${bg}${white_b}${text}${red} %B[$PREVIOUS_EXIT_CODE] %b${bg}${grey}${text}${white_b}${sharp}"
  }
  # 時計~ディレクトリ(三角含まない)
  clock_dir() {
    local clock="${text}${white} %D{%H:%M:%S} ${bg}${sky}${text}${grey}${sharp}"
    local dir="${text}${black} %B%~ %b"

    echo "${clock}${dir}"
  }
  # ディレクトリ三角(gitなし)
  dir_sharp_nogit() {
    echo "${reset}${text}${sky}${sharp}${reset}"
  }
  # ディレクトリ三角(gitあり)
  dir_sharp_git() {
    echo "${bg}${blue}${text}${sky}${sharp}"
  }
  # ブランチ
  branch() {
    local output
    if [ -n "$CUR_BRANCH_NAME" ]; then
      output=$CUR_BRANCH_NAME
    else
      output=$CUR_COMMIT_HASH
    fi
    echo "${text}${white} ${output}${GIT_STATUS} ${reset}${text}${blue}${sharp}${reset}"
  }
  # 2行目
  return_doller() {
    echo "\n${text}${green}\$${reset} "
  }

  local result
  # 前回の終了コードが0以外の場合
  if [ $PREVIOUS_EXIT_CODE -ne 0 ];then
    result=`previous_status_x`
  else
    result=`previous_status_o`
  fi

  result+=`clock_dir`

  # git管理されているかどうか
  if [ $IS_GIT_DIR -ne 0 ];then
    result+=`dir_sharp_git``branch`
  else
    result+=`dir_sharp_nogit`
  fi

  result+=`return_doller`

  echo $result
}

# git の状態を環境変数に記録
save_git_status_to_env() {
  # git管理されていないかどうか
  git status --porcelain >/dev/null 2>&1
  if [ $? -ne 0 ];then
    export IS_GIT_DIR=0
    export CUR_BRANCH_NAME=""
    export CUR_COMMIT_HASH=""
    export GIT_STATUS=""
  else
    export IS_GIT_DIR=1
    export CUR_BRANCH_NAME=$(git branch --show-current 2>/dev/null)
    export CUR_COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null)
    if [ -n "$(git status --short 2>/dev/null)" ]; then
      export GIT_STATUS="*"
    else
      export GIT_STATUS=""
    fi
  fi
}

# node_modules 以下の bin を PATH に追加するための direnv 設定ファイルを作成する
nodepath() {
  echo 'export PATH="$(npm bin):$PATH"' >> .envrc
  direnv allow
}

# fzf-command-history
fzf-command-history() {
  BUFFER=$(history -n -r 1 | fzf --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle reset-prompt
}
zle -N fzf-command-history
bindkey '^r' fzf-command-history

# fzf-cd - cd to selected directory
fzf-cd() {
  local dir
  dir=$(find ${1:-.} -path '*/\.*' -prune \
                  -o -type d -print 2> /dev/null | fzf +m) &&
  cd "$dir"
}

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
