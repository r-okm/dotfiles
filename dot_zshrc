# Misc
bindkey -e
setopt no_beep

# Alias
if [ -x /usr/bin/dircolors ]; then
  test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='ls --color=auto'
  alias dir='dir --color=auto'
  alias vdir='vdir --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'
fi
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
# compatible with windows
alias vi='nvim'
alias sz='source ~/.zshrc'
alias g='git'
alias n='npm'
alias nr='npm run'
alias ch='chezmoi'
alias amp='amplify'
alias tf='terraform'
alias dk='docker'
alias dkc='docker compose'
alias hex2dec="printf '%d\n'"
alias dec2hex="printf '%x\n'"
# linux only
alias clip='clip.exe'
alias relogin='su - $USER'

# Export
export LANG=ja_JP.utf8
export CLICOLOR=1
export EDITOR=nvim

# Completion
fpath=(
  ${HOME}/.zsh/completions
  $(brew --prefix)/share/zsh/site-functions
  $(brew --prefix asdf)/etc/bash_completion.d
  ${fpath}
)
autoload -Uz compinit && compinit
# ignore case
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# Application specific settings
# asdf
source $(brew --prefix)/opt/asdf/libexec/asdf.sh

# Prompt
function prompt_format {
  local text='%{\e[38;5;' # set text color
  local bg='%{\e[48;5;'   # set background color
  local reset='%{\e[0m%}' # reset
  local sharp='\uE0B0'    # triangle

  local green='002m%}'
  local white='007m%}'
  local grey='008m%}'
  local red='009m%}'
  local blue='024m%}'
  local cian='036m%}'
  local sky='110m%}'
  local black='232m%}'
  local white_b='254m%}'

  # 前回の終了ステータス(正常)
  function previous_status_o {
    echo "${bg}${white_b}${text}${cian} ✔  ${bg}${grey}${text}${white_b}${sharp}"
  }
  # 前回の終了ステータス(異常)
  function previous_status_x {
    echo "${bg}${white_b}${text}${red} ✘  ${bg}${grey}${text}${white_b}${sharp}"
  }
  # 時計~ディレクトリ(三角含まない)
  function clock_dir {
    local clock="${text}${white} %D{%H:%M:%S} ${bg}${sky}${text}${grey}${sharp}"
    local dir="${text}${black} %B%~ %b"

    echo "${clock}${dir}"
  }
  # ディレクトリ三角(gitなし)
  function dir_sharp_nogit {
    echo "${reset}${text}${sky}${sharp}${reset}"
  }
  # ディレクトリ三角(gitあり)
  function dir_sharp_git {
    echo "${bg}${blue}${text}${sky}${sharp}"
  }
  # ブランチ
  function branch {
    echo "${text}${white} ${BRANCH_NAME} ${reset}${text}${blue}${sharp}${reset}"
  }
  # 2行目
  function return_doller {
    echo "\n${text}${green}\$${reset} "
  }

  local result
  # 前回の終了コードが0以外の場合
  if [ $PREVIOUS_EXIT_CODE -ne 0 ];then
    result=`previous_status_x`
  else
    result=`previous_status_o`
  fi

  result+=`clock_dir`

  # git管理されているかどうか
  if [ $IS_GIT_DIR -ne 0 ];then
    result+=`dir_sharp_git``branch`
  else
    result+=`dir_sharp_nogit`
  fi

  result+=`return_doller`

  echo $result
}

function precmd {
    # 前回のコマンドの終了コード
    export PREVIOUS_EXIT_CODE=$?

    # git管理されていないかどうか
    git status --porcelain >/dev/null 2>&1
    if [ $? -ne 0 ];then
      export IS_GIT_DIR=0
      export BRANCH_NAME=""
    else
      export IS_GIT_DIR=1
      export BRANCH_NAME=$(git branch --show-current 2>/dev/null)
    fi

    # Promptの更新
    local p_f=`prompt_format`
    PROMPT=$p_f

    # 初回起動時以外､改行する
    if [ -z "$NEW_LINE_BEFORE_PROMPT" ]; then
        NEW_LINE_BEFORE_PROMPT=1
    elif [ "$NEW_LINE_BEFORE_PROMPT" -eq 1 ]; then
        echo ""
    fi
}

chpwd() {
    ls_abbrev
}
ls_abbrev() {
    if [[ ! -r $PWD ]]; then
        return
    fi
    # -a : Do not ignore entries starting with ..
    # -C : Force multi-column output.
    # -F : Append indicator (one of */=>@|) to entries.
    local cmd_ls='ls'
    local -a opt_ls
    opt_ls=('-aCF' '--color=always')
    case "${OSTYPE}" in
        freebsd*|darwin*)
            if type gls > /dev/null 2>&1; then
                cmd_ls='gls'
            else
                # -G : Enable colorized output.
                opt_ls=('-aCFG')
            fi
            ;;
    esac

    local ls_result
    ls_result=$(CLICOLOR_FORCE=1 COLUMNS=$COLUMNS command $cmd_ls ${opt_ls[@]} | sed $'/^\e\[[0-9;]*m$/d')

    local ls_lines=$(echo "$ls_result" | wc -l | tr -d ' ')

    if [ $ls_lines -gt 10 ]; then
        echo "$ls_result" | head -n 5
        echo '...'
        echo "$ls_result" | tail -n 5
        echo "$(command ls -1 -A | wc -l | tr -d ' ') files exist"
    else
        echo "$ls_result"
    fi
}
